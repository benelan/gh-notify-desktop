#!/usr/bin/env bash

# GitHub desktop notifications. Designed for polling the API responsibly by
# checking Last-Modified and adhering to X-Poll-Interval before making requests
# https://docs.github.com/en/rest/activity/notifications?apiVersion=2022-11-28
#
# Usage: run the extension in a systemd timer or cronjob, for example:
# */2 * * * * bash -l -c 'gh notify-desktop -p >> ~/.local/state/gh-notify-desktop/log 2>&1'

: "${DISPLAY=:0}"
: "${XAUTHORITY=~/.Xauthority}"
: "${DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u)/bus}"
: "${GH_TOKEN=$(gh auth token)}"

export DISPLAY XAUTHORITY GH_TOKEN DBUS_SESSION_BUS_ADDRESS

EXTENSION_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
DATA_DIR="${GH_ND_DATA_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/gh-notify-desktop}"
mkdir -p "$DATA_DIR"

# https://github.com/logos
if [ -f "$GH_ND_ICON" ]; then
    ICON="$GH_ND_ICON"
elif [ "$GH_ND_ICON" = "dark" ] && [ -f "$EXTENSION_DIR/img/github-mark.svg" ]; then
    ICON="$EXTENSION_DIR/img/github-mark.svg"
elif [ -f "$EXTENSION_DIR/img/github-mark-white.svg" ]; then
    ICON="$EXTENSION_DIR/img/github-mark-white.svg"
fi

PARTICIPATING=false
ALL=false

die() {
    echo "Something went wrong..." >&2
    exit 1
}

check_poll_interval() {
    local now last_checked time_since_last_check poll_interval remaining_poll_wait

    now="$(date +'%s')"
    last_checked="$(cat "$DATA_DIR/last-checked" 2>/dev/null)"

    if [ -n "$last_checked" ]; then
        time_since_last_check=$((now - last_checked))
        poll_interval="$(cat "$DATA_DIR/poll-interval" 2>/dev/null)"

        if [ -n "$poll_interval" ]; then
            remaining_poll_wait=$((poll_interval - time_since_last_check))

            if [ "$remaining_poll_wait" -gt 0 ]; then
                echo "Please wait $remaining_poll_wait seconds before checking for GitHub notifications again" >&2
                exit 3
            fi
        fi
    fi

    echo "$now" >"$DATA_DIR/last-checked"
}

check_response_headers() {
    local headers status_code last_modified poll_interval

    resp="$(
        # jq expression adopted from https://github.com/meiji163/gh-notify
        gh api -i "/notifications?participating=$PARTICIPATING&all=$ALL" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "If-Modified-Since: $(
                [ -z "$DEBUG" ] && cat "$DATA_DIR/last-modified" 2>/dev/null
            )" \
            --jq $'.[] | {
            # The "if" needs to be wrapped in parentheses, otherwise it will fail on some OSs.
            updated_short:
                # for some reason ".updated_at" can be null
                (if .updated_at then
                    .updated_at | fromdateiso8601 | strftime("%Y-%m")
                else
                    # Github Discussion launched in 2020
                    # https://resources.github.com/devops/process/planning/discussions/
                    "2020"
                end),
            # UTC time ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
            # https://docs.github.com/en/rest/overview/resources-in-the-rest-api#timezones
            iso8601: now | strftime("%Y-%m-%dT%H:%M:%SZ"),
            thread_id: .id,
            thread_state: (if .unread then "UNREAD" else "READ" end),
            comment_url: .subject.latest_comment_url | tostring | split("/") | last,
            repo_full_name: .repository.full_name,
            # make sure each outcome has an equal number of fields separated by spaces
            timefmt: (
                # for some reason ".updated_at" can be null
                if (.unread and .last_read_at) or .updated_at then
                    ((if .unread then .last_read_at // .updated_at else .updated_at end) | fromdateiso8601) as $time_sec |
                    # difference is less than one hour
                    if ((now - $time_sec) / 3600) < 1 then
                        (now - $time_sec) / 60 | floor | tostring + "min ago"
                    # difference is less than 24 hours
                    elif ((now - $time_sec) / 3600) < 24 then
                        (now - $time_sec) / 3600 | floor | tostring + "h ago"
                    else
                        $time_sec | strflocaltime("%d/%b %H:%M")
                    end
                else
                    "Not available"
                end),
            owner_abbreviated: (
                if (.repository.owner.login | length) > 10 then
                    .repository.owner.login | .[0:9]  | tostring + "… "
                else
                    .repository.owner.login
                end),
            name_abbreviated: (
                if (.repository.name | length) > 13 then
                    .repository.name | .[0:12] | tostring + "… "
                else
                    .repository.name
                end),
            type: .subject.type,
            # Some infos have to be pulled from this URL in later steps, so no string modifications.
            url: .subject.url | tostring,
            reason: .reason,
            title: .subject.title
            } | [
            .updated_short, .iso8601, .thread_id, .thread_state, .comment_url, .repo_full_name,
            .timefmt, "\(.owner_abbreviated)/\(.name_abbreviated)", .type, .url,
            .reason, .title
        ] | @tsv' 2>"$DATA_DIR/log"
    )"

    [ -n "$DEBUG" ] && echo "$resp"

    headers="$(head -n-1 <<<"$resp")"
    # body="$(tail -n1 <<<"$resp")"

    status_code="$(head -n1 <<<"$headers" | cut -d ' ' -f2)"

    last_modified="$(
        grep --ignore-case last-modified <<<"$headers" |
            awk -F ': ' '{print $2}'
    )"

    poll_interval="$(
        grep --ignore-case x-poll-interval <<<"$headers" |
            awk -F ': ' '{print $2}' |
            tr -dc '[:digit:]'
    )"

    if [ -n "$last_modified" ]; then
        echo "$last_modified" >"$DATA_DIR/last-modified"
    fi

    if [ -n "$poll_interval" ]; then
        echo "$poll_interval" >"$DATA_DIR/poll-interval"
    fi

    if [ "$status_code" = "200" ]; then
        echo "There are new GitHub notifications" >&2
        # # don't create a desktop notification if the io streams are a tty
        if [ -t 0 ] && [ -t 1 ]; then
            exit 0
        fi
    elif [ "$status_code" = "304" ]; then
        echo "Up to date on GitHub notifications" >&2
        exit 2
    else
        echo "GitHub responded with status code $status_code" >&2
        exit 1
    fi
}

notify_with_dunst() {
    local cli_action web_action action_response

    # Add dunstify action to open if the gh-notify extension is installed
    # and if the TERMINAL environment variable is set to a supported emulator
    # https://github.com/meiji163/gh-notify
    if gh extension list | grep -q 'gh notify' 2>/dev/null &&
        [[ "$TERMINAL" =~ ^(x-terminal-emulator|xterm|wezterm|kitty|alacritty|gnome-terminal|konsole|foot|eterm|st)$ ]]; then
        cli_action="cli,open in gh-notify"
    fi

    if [ -n "$GH_BROWSER" ] || [ -n "$BROWSER" ]; then
        web_action="web,open in browser"
    fi

    action_response=$(
        dunstify "GitHub" "new notification(s)" -a "gh-notify-desktop" \
            ${ICON:+-i "$ICON"} \
            ${web_action:+-A "$web_action"} \
            ${cli_action:+-A "$cli_action"}
    )

    if [ "$PARTICIPATING" = true ]; then
        query+="reason%3Aparticipating&"
        flags+=" -p"
    fi

    if [ "$ALL" = false ]; then
        query+="is%3Aunread"
    else
        flags+=" -a"
    fi

    case "$action_response" in
        web) ${GH_BROWSER:-$BROWSER} "https://github.com/notifications?query=$query" ;;
        cli) $TERMINAL -e sh -c "gh notify$flags" ;;
    esac
}

while getopts i:aph opt; do
    case $opt in
        a) ALL=true ;;
        p) PARTICIPATING=true ;;
        i) [ -f "$OPTARG" ] && ICON="$OPTARG" ;;
        h) die ;;
        *) die ;;
    esac
done

shift "$((OPTIND - 1))"

[ -z "$DEBUG" ] && check_poll_interval
check_response_headers
notify_with_dunst
